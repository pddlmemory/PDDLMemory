#!/usr/bin/env python

# memoplan.py
#
# This is MemoPlan, the launcher for the PDDLMemory module. (CSV Output)
#
# Created: 07/24/2014
# Author: Ivo Chichkov

# modules
from pddlmemory.main import PDDLMemory
from pddlmemory.ce import PDDLMemoryCE

# lib
import argparse
import sys
import os
import pickle
import csv

# config
from pddlmemory.config import print_plan_steps
from pddlmemory.config import maximum_iterations
from pddlmemory.config import output_path
from pddlmemory.config import current_domain_name


###
# NOTES
#
# reusable code:
#   * color print output
#   * list comprehension: join items of a list together using string as a connector
#   * write a CSV file
#
# to do:
#   * done
#
###

# a list storing the complete plan generated by memoplan
complete_plan = []

# was the planning successful (ie. all goals solved?)
all_goals_solved = False

# Functions for formatting the output
def cp(text, color):
    """ colorprint """
    col = color
    print text,
    # screen.cprint(col, None, text)
    # screen.reset()
    return ''


# Printing output with symbols ("moods") to enhance readability
def memoprint(text, label="", mood="norm", br=0):
    """ print output in memoplan's format """
    m = {"norm" : "[* *] ",
         "list" : " [->] ",
         "plan" : "[ P ] ",
         "hppy" : "[0 0] ",
         "sad"  : "[= =] ",
         "no"   : "",
         }
    label = (label + ": " if label else "")
    print "\n"*br, cp(m[mood], 1), cp(label, 10), cp(text, 7)


def init_print():
    pass
    # global screen
    # screen = terminal.get_terminal(conEmu=False)
    # screen.set_title("MemoPlan")


def print_plan(planner_output):
    """
    Print the plan if it exists otherwise print a message
    that no plan has been found.
    """
    if planner_output.is_solution():
        memoprint("Plan has been found.",
                  label="PDDLMemoryCE", mood="hppy", br=1)
        steps = planner_output.get_steps()

        if print_plan_steps:
            memoprint("Printing...", label="PDDLMemoryCE", mood="norm")
            # check for an empty plan
            if len(steps) == 0:
                memoprint("< Empty Plan >", mood="plan")
            else:
                for s in steps:
                    fs = format_step(s)
                    # store the partial plan produced sofar as a complete plan
                    complete_plan.append(fs)
                    memoprint(fs, mood="plan")
            memoprint("Plan output finished.", label="PDDLMemoryCE", br=1)
    else:
        memoprint("No plan found.", label="PDDLMemoryCE", mood="sad", br=1)

def print_complete_plan():
    """
    Print the complete plan collected during execution.
    """
    memoprint("Printing complete plan generated:", label="PDDLMemory", br=1)
    for s in complete_plan:
        memoprint(s, mood="plan")

def output_complete_plan(path):
    """
    Dump the complete plan collected during execution to a file. (as plaintext)
    """
    with open(path+"/plan", "w") as f:
        for s in complete_plan:
            f.write(s + "\n")

def dump_complete_plan():
    """
    Dump the complete plan collected during execution to a file. (as a pickle object)
    """
    output = (complete_plan, all_goals_solved)
    pickle.dump(output, open(output_path+"pddlmemory_plan", "wb"))


def format_step(step):
    formated_step = \
        '(' + reduce(lambda x, y: x.lower() + " " + y.lower(), step) + ')'
    return formated_step

def create_output_folder():
    domain_output_folder = output_path + "/" + current_domain_name
    # create the folder if it doesent exist
    try:
        os.makedirs(domain_output_folder)
    except OSError, e:
        # empty folder if it already exists
        if e.errno == 17:
             for f in os.listdir(domain_output_folder):
                os.remove(domain_output_folder + "/" + f)
        # if another error occured, raise exception
        else:
            raise
###


def main():

    # init
    init_print()
    create_output_folder()
    global all_goals_solved

    # parse the command line arguments
    parser = argparse.ArgumentParser(
        description="MemoPlan is the launcher for the PDDLMemory module. This version outputs a CSV file in the domain folder.")
    parser.add_argument(
        "--say-hi", action="store_true", dest="say_hi")
    # parser.add_argument("--domain-name", "-d", dest="domain_name",
    #                     help="The PDDLMemory domain name.")
    parser.add_argument("--list-facts", action="store_true", dest="list_facts",
                        help="Dump the facts of all active nodes.")
    parser.add_argument("--list-goals", action="store_true", dest="list_goals",
                        help="Dump the goals of all active nodes.")
    parser.add_argument("--list-items", action="store_true",
                        dest="list_items",
                        help="List all items loaded in memory." +
                        " (e.g. PlaceNodes)")
    parser.add_argument("--list-active-items", action="store_true",
                        dest="list_active_items",
                        help="List active items loaded in memory.")
    parser.add_argument("--deactivate-items", nargs="*",
                        dest="deactivate_items",
                        help="Deactivate a list of items. (by list of ids)")
    parser.add_argument("--single-item", dest="single_item",
                        help="Activate only a single item. (by id)")
    parser.add_argument("--plan", action="store_true",
                        dest="plan",
                        help="Run the planner")
    parser.add_argument("--planning-strategy", "-s", dest="plan_strategy",
                        choices=["progressive-activation",
                                 "progressive-goalrem",
                                 "directed-rehearsal"],
                        help="Run the planner using a memory supported " +
                        "planning strategy. The directed-rehearsal strategy " +
                        "outputs a CSV file.")


    args = parser.parse_args()

    # print a greeting
    if args.say_hi:
        print cp("[+ +] ", 1), cp("Hi, this is ", 7), \
            cp("MemoPlan ", 1), cp("the PDDLMemory launcher.", 7),
        sys.exit(0)

    memoprint("Up and running, for more info try: ./memoplan -h")

    # initialize memory and load the current domain
    memory = PDDLMemory()
    memory.loadDomain()
    # initialize the central executive
    ce = PDDLMemoryCE(memory)

    memoprint("Memory initialized.", label="PDDLMemory")

    # deactivating all but a single item
    if args.single_item:
        memoprint("Activating only a single item: " + args.single_item,
                  label="PDDLMemory", br=1)
        for i in memory.retreiveActiveItems():
            if str(i) != args.single_item:
                memory.deactivateItem(str(i))

    # deactivating items
    if args.deactivate_items:
        memoprint("Deactivating selected items.", label="PDDLMemory")
        for i in args.deactivate_items:
            memory.deactivateItem(i)

    # listing all items
    if args.list_items:
        memoprint("Listing ALL items...", label="PDDLMemory",
                  mood="norm", br=1)
        for i in memory.retreiveItems():
            memoprint(i, mood="list")

    # listing active items
    if args.list_active_items:
        memoprint("Listing ACTIVE items...", label="PDDLMemory",
                  mood="norm", br=1)
        for i in memory.retreiveActiveItems():
            memoprint(i, mood="list")

    # listing active facts
    if args.list_facts:
        memoprint("Listing ACTIVE facts...", label="PDDLMemory",
                  mood="norm", br=1)
        for i in memory.retreiveActiveItems():
            node = i.getObject()
            for l in node.dumpFactsToPDDL().split("\n"):
                memoprint(l, mood="list")

    # listing active goals
    if args.list_goals:
        memoprint("Listing ACTIVE goals...", label="PDDLMemory",
                  mood="norm", br=1)
        for i in memory.retreiveActiveItems():
            node = i.getObject()
            goals_pddl = node.dumpGoalsToPDDL()
            if goals_pddl == "":
                continue
            for l in goals_pddl.split("\n"):
                    memoprint(l, mood="list")

    # running the planner
    if args.plan:
        memoprint(
            "Running planner...", label="PDDLMemoryCE", mood="norm", br=1)
        planner_output = ce.runPlannerOnce()
        print_plan(planner_output)

    # running the planner with a plan strategy
    if args.plan_strategy:
        # repeated execution of the planner
        # progressively add more nodes (progressive activation)

        # variables for output storage
        # an array of plans that are generated in every iteration
        plans = []
        # an array tracking the number of unsolved goals
        u_goals = []
        # an array tracking the currently active chunks
        active_chunks = []

        if args.plan_strategy == "progressive-activation":
            planner_iterator = ce.progressiveActivation()
            while True:
                try:
                    memoprint("Running planner...", label="PDDLMemoryCE", br=1)
                    planner_output = next(planner_iterator)
                    memoprint("Currently ACTIVE items:", label="PDDLMemory",
                              br=1)
                    for i in memory.retreiveActiveItems():
                        memoprint(i, mood="list")
                    print_plan(planner_output)

                    # Log planning progress
                    active = [str(i) for i in memory.retreiveActiveItems()]
                    plans.append(planner_output)
                    active_chunks.append(active)
                    # label = str(len([i for i in memory.retreiveActiveItems()])) + \
                    #   " items"

                except StopIteration:
                    memoprint("No nodes more to add, finished.",
                              label="PDDLMemoryCE")
                    break

        # repeated execution of the planner
        # progressively add more nodes (progressive activation)
        # remove goals when they are solved (goal removal)
        elif args.plan_strategy == "progressive-goalrem":
            planner_iterator = ce.progressiveActivation(
                goalRemoval=True)
            while True:
                try:
                    memoprint("Running planner...", label="PDDLMemoryCE", br=1)
                    planner_output = next(planner_iterator)
                    memoprint("Currently ACTIVE items:", label="PDDLMemory",
                              br=1)
                    for i in memory.retreiveActiveItems():
                        memoprint(i, mood="list")
                    print_plan(planner_output)

                    # Log planning progress
                    active = [str(i) for i in memory.retreiveActiveItems()]
                    plans.append(planner_output)
                    active_chunks.append(active)
                    # label = str(len([i for i in memory.retreiveActiveItems()])) + \
                    #   " items"

                except StopIteration:
                    memoprint("No nodes more to add, finished.",
                              label="PDDLMemoryCE")
                    break

        # directed rehearsal strategy
        elif args.plan_strategy == "directed-rehearsal":
            planner_iterator = ce.directedRehearsal()
            iteration_counter = 1
            activation_count_dict = {}
            while True:
                try:
                    memoprint("Running planner...", label="PDDLMemoryCE", br=1)
                    planner_output, solved_goals, total_goals = next(planner_iterator)
                    memoprint("Currently ACTIVE items:", label="PDDLMemory",
                              br=1)
                    for i in memory.retreiveActiveItems():
                        # count the number of activations for every item
                        ac = activation_count_dict.get(str(i),0) + 1
                        activation_count_dict[str(i)] = ac

                        memoprint(i, mood="list")
                    print_plan(planner_output)

                    memoprint("Number of solved goals: " + str(solved_goals),
                              label="PDDLMemoryCE")
                    memoprint("Number of total goals: " + str(total_goals),
                              label="PDDLMemoryCE")

                    # Log planning progress
                    active = [str(i) for i in memory.retreiveActiveItems()]
                    plans.append(planner_output)
                    active_chunks.append(active)
                    u_goals.append(total_goals-solved_goals)
                    # label = str(len([i for i in memory.retreiveActiveItems()])) + \
                    #   " items"

                    iteration_counter += 1

                except StopIteration:

                    all_goals_solved = True if (total_goals == solved_goals) else False

                    memoprint("Planning using directed-rehearsal finished."+str(total_goals)+"/"+str(solved_goals),
                              label="PDDLMemoryCE")
                    break

                iterations = iteration_counter - 1
                memoprint("Total number of iterations: " +
                          str(iterations))
                memoprint("Activations per item:")
                for a in activation_count_dict:
                    memoprint(a + ":" + str(activation_count_dict[a]),
                              mood="list")


        # print a warning if planning strategy is not valid
        else:
            memoprint("Please use a valid planning strategy.", label="PDDLMemoryCE", mood="sad")
            sys.exit(1)


        if args.plan_strategy == "directed-rehearsal":
            # generate output file for directed-rehearsal

            plan_steps = [len(p.get_steps()) for p in plans]
            planning_times =  [p.get_info()["total_time"] for p in plans]
            is_solution = [p.is_solution() and not p.is_empty() for p in plans]

            # the result array which gets written to a CSV
            result = [plan_steps, planning_times, is_solution, u_goals, active_chunks]

            with open(output_path + current_domain_name + "/results.csv", "wb") as csvfile:
                csvwriter = csv.writer(csvfile, delimiter=",",
                    quotechar="\"", quoting=csv.QUOTE_MINIMAL)

                # write a row for every iteration
                csvwriter.writerow(["nr_plan_steps", "planning_time", "is_solution", "unsolved_goals", "active_chunks"])
                for n in range(len(result[0])):
                    csvwriter.writerow([result[i][n] for i in range(len(result))])

            # extend the result lists to the lenght of the maximum_iteration
            # i.e if the list is
            # cur_listlen = len(result[0])
            # new_listlen = maximum_iterations+1
            # for j in range(len(result)):
            #     result[j] = [result[j] if i < len(result[j]) else fillers[j] for i in range(listlen)]

            # u_goals = [u_goals[i] if i < len(u_goals) else 0 for i in range(listlen)]
            # plans = [plans[i] if i < len(plans) else None for i in range(listlen)]
            # active_chunks = [active_chunks[i] if i < len(active_chunks) else [] for i in range(listlen) ]

            # print(len(u_goals))
            # print(len(active_chunks))
            # print "u_goals_ext", u_goals
            # print "plans_ext", plans


    dump_complete_plan() # pickle
    output_complete_plan(output_path + "/" + current_domain_name) # plaintext
    # print_complete_plan()
    memoprint("MemoPlan exited normally.", br=1)

if __name__ == "__main__":
    main()